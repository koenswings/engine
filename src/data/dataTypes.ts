import { Doc, Map as YMap } from 'yjs'
import { WebsocketProvider } from '../y-websocket/y-websocket.js'

// TODOS
// 1. Backup Disks


// ChatGPT Instructions
// We need a TypeScript data model
// We have a collection of App Instances which are instances of Apps
// Each App Instance has the following properties:
// - the name of the App it is an instance of
// - the version of the App it is an instance of
// - the category of the App it is an instance of (e.g. "Productivity", "Utilities", "Games")
// - the desciption of the App it is an instance of
// - the icon of the App it is an instance of
// - the name of the App Instance
// - the status of the App Instance (e.g. "Running", "Paused", "Error")
// - the Docker metrics of the App Instance (e.g. CPU, Memory, Network, Disk)
// - the Docker logs of the App Instance
// - the Docker events of the App Instance
// - the Docker configuration of the App Instance
// - the time and date the App Instance was created
// - the time and date the App Instance was last backed up
// - the time and date the App Instance was last started
// - a flag indicating that it can be upgraded
// - a flag indicating that it can be backed up
// - the Disk on which the App Instance is stored
// The Disk has the following properties:
// - the name of the Disk
// - the time and date the Disk was created
// - the time and date the Disk was last docked
// - a flag indicating that it can be removed
// - a flag indicating that it can be upgraded
// - the Engine on which the Disk is stored
// The Engine has the following properties:
// - the hostName of the Engine
// - the version of the Engine
// - the host OS it is running on (e.g. "Raspberri Pi OS version 2023-05-12")
// - the status of the Engine (e.g. "Running", "Paused", "Error")
// - the Docker metrics of the Engine (e.g. CPU, Memory, Network, Disk)
// - the Docker logs of the Engine
// - the Docker events of the Engine
// - the time and date the Engine was last booted
// That's it. We need to define the TypeScript data model for this.


// **********
// Generated by Github Copilot
// **********

// 


// **********
// Generated by ChatGPT 4.0
// **********

type AppCategory = 'Productivity' | 'Utilities' | 'Games';

export type Status = 'Running' | 'Paused' | 'Error';

type DiskType = 'Apps' | 'Backup';


type URL = string;

// export interface Version {
//   major: number;
//   minor: number;
// }

type Version = string; // Can be major.minor or a commit hash

export interface DockerMetrics {
  cpu: string;
  memory: string;
  network: string;
  disk: string;
}

export interface DockerLogs {
  logs: string[]; // Assuming logs are strings, but this could be more complex
}

export interface DockerEvents {
  events: string[]; // Similarly, assuming simple string descriptions
}

// interface DockerConfiguration {
//   // Define the structure according to the Docker configuration specifics
//   [key: string]: any; // Placeholder, adjust as needed
// }

export interface Engine {
  hostName: string;
  version: Version;
  hostOS: string;
  status: Status;
  dockerMetrics: DockerMetrics;
  dockerLogs: DockerLogs;
  dockerEvents: DockerEvents;
  lastBooted: number; // We must use a timestamp number as Date objects are not supported in YJS
  disks: Disk[],
  networkInterfaces: NetworkInterface[];
  commands: Command[];
 }

export interface Disk {
  name: string;
  device: string;
  type: DiskType;
  created: number; // We must use a timestamp number as Date objects are not supported in YJS
  lastDocked: number; // We must use a timestamp number as Date objects are not supported in YJS
  removable: boolean;
  upgradable: boolean;
  //engine: Engine;   
  apps: App[];     
  instances: Instance[];     
}

export interface App {
  name: string;
  version: Version;
  title: string;
  description: string;
  url: URL
  category: AppCategory;
  icon: URL;
  author: string;
}


export interface Instance {
  instanceOf: string;   // Reference by name since we can store the AppMaster object only once in Yjs
  name: string;
  status: Status;
  port: number;
  dockerMetrics: DockerMetrics;
  dockerLogs: DockerLogs;
  dockerEvents: DockerEvents;
  created: number; // We must use a timestamp number as Date objects are not supported in YJS
  lastBackedUp: number; // We must use a timestamp number as Date objects are not supported in YJS
  lastStarted: number; // We must use a timestamp number as Date objects are not supported in YJS
  upgradable: boolean;
  backUpEnabled: boolean;
  //disk: Disk;
}

type NetworkID = string;

export interface NetworkInterface {
  id: string;       // == network + iface since we can have multiple interfaces to the same network and multiple networks on the same interface
  network: string;  // The network to which this interface connects  Reference by name since we do not want to expose Yjs details to the proxy
  iface: string
  ip4: string;
  netmask: string;
}

// The root level Network object which is NOT proxied  
export interface Network {
  name: string;    // The unique identifier of the Network
  doc: Doc;
  data: NetworkData;       // The Valtio-yjs proxy object through which we capture Yjs changes
  yData: any;              // The correspond YMap object
  unbind: () => void;      // The unbind function to disconnect the Valtio-yjs proxy from the Yjs object

  // A map of interface-ipaddress to WebsocketProvider objects
  // Lists all the websocket providers for the network (so all the engines to which the doc of the Network syncs to)
  // The key is the ip address of the engine and we also append the interface name over which this connection is made
  wsProviders: {[key: string]: WebsocketProvider}
}

export type Listener = {[key: string]: (data: any) => void}  // The key is the interface name and the value is the listener function

// Define an object that stores all running servers on the local engine
// It should have the ip address as a key and a truth value to indicate if the server is running
// Add a type definition for this object
export type RunningServers = {
  [ip: string]: boolean
}

// export interface NetworkData {
//   engines: Engine[] 
//   //disks: Disk[];
//   //apps: App[];
// }
// HACK - 
export interface NetworkData {
  [key: string]: any;
}

// Generalized argument types
type ArgumentType = 'string' | 'number' | 'object';

// Updated FieldSpec to support multiple types
interface FieldSpec {
    type: 'number' | 'string'; // Extend this as needed
}

interface ObjectSpec {
    [key: string]: FieldSpec;
}

// Updated ArgumentDescriptor to include ObjectSpec
export interface ArgumentDescriptor {
    type: ArgumentType;
    objectSpec?: ObjectSpec;
}

// Interface for commands
export interface Command {
    name: string;
    execute: (...args: any[]) => void;
    args: ArgumentDescriptor[];
}


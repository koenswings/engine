import { Doc, Map as YMap } from 'yjs'
import { WebsocketProvider } from '../y-websocket/y-websocket.js'

// TODOS
// 1. Backup Disks


// ChatGPT Instructions
// We need a TypeScript data model
// We have a collection of App Instances which are instances of Apps
// Each App Instance has the following properties:
// - the name of the App it is an instance of
// - the version of the App it is an instance of
// - the category of the App it is an instance of (e.g. "Productivity", "Utilities", "Games")
// - the desciption of the App it is an instance of
// - the icon of the App it is an instance of
// - the name of the App Instance
// - the status of the App Instance (e.g. "Running", "Paused", "Error")
// - the Docker metrics of the App Instance (e.g. CPU, Memory, Network, Disk)
// - the Docker logs of the App Instance
// - the Docker events of the App Instance
// - the Docker configuration of the App Instance
// - the time and date the App Instance was created
// - the time and date the App Instance was last backed up
// - the time and date the App Instance was last started
// - a flag indicating that it can be upgraded
// - a flag indicating that it can be backed up
// - the Disk on which the App Instance is stored
// The Disk has the following properties:
// - the name of the Disk
// - the time and date the Disk was created
// - the time and date the Disk was last docked
// - a flag indicating that it can be removed
// - a flag indicating that it can be upgraded
// - the Engine on which the Disk is stored
// The Engine has the following properties:
// - the hostName of the Engine
// - the version of the Engine
// - the host OS it is running on (e.g. "Raspberri Pi OS version 2023-05-12")
// - the status of the Engine (e.g. "Running", "Paused", "Error")
// - the Docker metrics of the Engine (e.g. CPU, Memory, Network, Disk)
// - the Docker logs of the Engine
// - the Docker events of the Engine
// - the time and date the Engine was last booted
// That's it. We need to define the TypeScript data model for this.


// **********
// Generated by Github Copilot
// **********

// 


// **********
// Generated by ChatGPT 4.0
// **********

type AppCategory = 'Productivity' | 'Utilities' | 'Games';

export type Status = 'Running' | 'Paused' | 'Error';
export type ConnectionStatus = 'Connected' | 'Disconnected';


type DiskType = 'Apps' | 'Backup';


type URL = string;

// export interface Version {
//   major: number;
//   minor: number;
// }

type Version = string; // Can be major.minor or a commit hash

export interface DockerMetrics {
  cpu: string;
  memory: string;
  network: string;
  disk: string;
}

export interface DockerLogs {
  logs: string[]; // Assuming logs are strings, but this could be more complex
}

export interface DockerEvents {
  events: string[]; // Similarly, assuming simple string descriptions
}

// interface DockerConfiguration {
//   // Define the structure according to the Docker configuration specifics
//   [key: string]: any; // Placeholder, adjust as needed
// }

export interface Engine {
  hostName: string;
  version: Version;
  hostOS: string;
  dockerMetrics: DockerMetrics;
  dockerLogs: DockerLogs;
  dockerEvents: DockerEvents;
  lastBooted: number; // We must use a timestamp number as Date objects are not supported in YJS
  disks: Disk[];
  //networkInterfaces: NetworkInterface[];
  interfaces: {[key: string]: Interface} // The key is the interface name and the value is the Interface object
  commands: string[];
 }

export interface Disk {
  name: string;
  device: string;
  type: DiskType;
  created: number; // We must use a timestamp number as Date objects are not supported in YJS
  lastDocked: number; // We must use a timestamp number as Date objects are not supported in YJS
  removable: boolean;
  upgradable: boolean;
  //engine: Engine;   
  apps: App[];     
  instances: Instance[];     
}

export interface App {
  name: string;
  version: Version;
  title: string;
  description: string;
  url: URL
  category: AppCategory;
  icon: URL;
  author: string;
}


export interface Instance {
  instanceOf: string;   // Reference by name since we can store the AppMaster object only once in Yjs
  name: string;
  status: Status;
  port: number;
  dockerMetrics: DockerMetrics;
  dockerLogs: DockerLogs;
  dockerEvents: DockerEvents;
  created: number; // We must use a timestamp number as Date objects are not supported in YJS
  lastBackedUp: number; // We must use a timestamp number as Date objects are not supported in YJS
  lastStarted: number; // We must use a timestamp number as Date objects are not supported in YJS
  upgradable: boolean;
  backUpEnabled: boolean;
  //disk: Disk;
}

type NetworkID = string;

// We give an engine an Interface once it has an IP address on that interface
export interface Interface {
  name: string
  ip4: string;
  netmask: string;
}


// Create a type called Connections that represents all connections that a Network has
// The connections are sorted per interface and per ip address of the Engin that the Network is connected to
// (a Network can be connected to multiple Engines on one Interface)
export type Connection = WebsocketProvider
export type Connections = {[key: string]: {[key: string]: Connection}}   // The first key is the interface and the second key is the ip address

// Create a type called IfaceListeners that represents all listeners that a Network has 
// The listeners are sorted per interface name
export type Listener = (data: any) => void 
export type Listeners = {[key: string]: Listener}  // The key is the interface name 


// The root level Network object which is NOT proxied  
export interface Network {
  name: string;    // The unique identifier of the Network
  doc: Doc;
  data: NetworkData;       // The Valtio-yjs proxy object through which we capture Yjs changes
  yData: any;              // The correspond YMap object
  unbind: () => void;      // The unbind function to disconnect the Valtio-yjs proxy from the Yjs object

  // All connected engines sorted per interface
  connections: Connections;
  listeners: Listeners;

}

// Define an object that stores all running servers on the local engine
// It should have the ip address as a key and a truth value to indicate if the server is running
// Add a type definition for this object
// UPDATE001: Uncomment the following code in case we want to only open sockets on the interfaces that we monitor
// export type RunningServers = {
//   [ip: string]: boolean
// }

export interface NetworkData {
  engines: Engine[] 
  //disks: Disk[];
  //apps: App[];
}
// HACK - 
// export interface NetworkData {
//   [key: string]: any;
// }


export type ConnectionResult = { status: string; networkData: NetworkData }

// Generalized argument types
type ArgumentType = 'string' | 'number' | 'object';

// Updated FieldSpec to support multiple types
interface FieldSpec {
    type: 'number' | 'string'; // Extend this as needed
}

interface ObjectSpec {
    [key: string]: FieldSpec;
}

// Updated ArgumentDescriptor to include ObjectSpec
export interface ArgumentDescriptor {
    type: ArgumentType;
    objectSpec?: ObjectSpec;
}

// Interface for commands
export interface CommandDefinition {
    name: string;
    execute: (...args: any[]) => void;
    args: ArgumentDescriptor[];
}

